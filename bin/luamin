#!/usr/bin/env node
(function() {

	var fs = require('fs');
	var nopt = require('nopt');
	var luamin = require('../luamin.js');
	var minify = luamin.minify;
	var isFile = false;
	var isAST = false;
	var newlineSeparator = false;
	var minifyMemberNames = false;
	var minifyTableKeyStrings = false;
	var minifyAssignedGlobalVars = false;
	var minifyGlobalFunctions = false;
	var minifyAllGlobalVars = false;
	var stdin = process.stdin;
	var data;
	var log = console.log;
	var err = console.error;

	/* nopt configuration */

	// option names and types
	var knownOpts = {
		"code": Boolean,
		"file": Boolean,
		"ast": Boolean,
		"newline-separator": Boolean,
		"minify-member-names": Boolean,
		"minify-table-key-strings": Boolean,
		"minify-assigned-global-vars": Boolean,
		"minify-global-functions": Boolean,
		"minify-all-global-vars": Boolean,
		"version": Boolean,
		"help": Boolean,
	};

	// explicit option shorthands (nopt generates such shorthands automatically,
	// but passing them explicitly enables option initial letters mixup like '-cn')
	var shortHands = {
		"c": ["--code"],
		"f": ["--file"],
		"a": ["--ast"],
		"n": ["--newline-separator"],
		"m": ["--minify-member-names"],
		"k": ["--minify-table-key-strings"],
		"G": ["--minify-assigned-global-vars"],
		"F": ["--minify-global-functions"],
		"g": ["--minify-all-global-vars"],
		"v": ["--version"],
		"h": ["--help"]
	}

	// pass 2 as last argument to skip "node" and "luamin" paths
	var parsed = nopt(knownOpts, shortHands, process.argv, 2);

	// get positional arguments (caution: it will also get unknown options)
	var snippets = parsed.argv.remain

	var main = function() {

		if (parsed.help) {
			log('luamin v%s - https://mths.be/luamin', luamin.version);
			log([
				'\nUsage:\n',
				'  luamin [-c | --code] [snippet ...]',
				'  luamin [-f | --file] [file ...]',
				'  luamin [-a | --ast] [AST ...]',
				'  luamin [-v | --version]',
				'  luamin [-h | --help]',
				'\nOptions:\n',
				"  -n, --newline-separator\tjoin statements with '\\n' instead of ';'",
				'  -m, --minify-member-names\tforce minification of member expressions not starting with \'_\'',
				'  -k, --minify-table-key-strings\tforce minification of table key strings not starting with \'_\'',
				'  -G, --minify-assigned-global-vars\tforce minification of assigned global variables (not native nor defined in external file) not starting with \'_\'.',
				'                                   \tThis only works when global variables are assigned before usage in the code, so if you need early usage, you should',
				'                                   \tadd a dummy assignment like `my_global = nil` before any usage in code.',
				'  -F, --minify-global-functions\tforce minification of all global function declarations when name is not starting with \'_\'. Strongly recommended with --minify-assigned-global-vars, since function foo() ... is a common alternative to foo = function() ...',
				'  -g, --minify-all-global-vars\tforce minification of all global variables not starting with \'_\'. Stronger than --minify-assigned-global-vars, only use one or the other.',
				'\nExamples:\n',
				'  luamin -c \'a = ((1 + 2) - 3) * (4 / (5 ^ 6))\'',
				'  luamin -f foo.lua',
				'  echo \'a = "foo" .. "bar"\' | luamin -c -',
				'  luaparse --scope \'a = 42\' | luamin -a -',
				'  luamin -cn \'a = 5; b = 6\'',
				'  luamin -cm \'t.key = 6; t._preserved = 7; t["preserved"] = 8\'',
				'  luamin -ck \'t = { key = 6, _preserved = 7, ["preserved"] = 8 }\'',
				'  luamin -cmk \'t = { key = 6, _preserved = 7, ["preserved"] = 8 }; t.key = 0\'',
				'  luamin -cG \'minified_global = 1; _protected_global = 2; local minified_alias_for_protected_native = pairs\'',
				'  luamin -cg \'minified_global = 1; _protected_global = 2; minified_external_global()\''
			].join('\n'));
			return process.exit(1);
		}

		if (parsed.version) {
			log('v%s', luamin.version);
			return process.exit(1);
		}

		if (parsed.file) {
			isFile = true;
		} else if (parsed.ast) {
			isAST = true;
		} else if (!parsed.code) {
			err('Error: if `luamin` is not used to print help or version, either ' +
				'--file, --ast or --code should be used.');
			err('Try `luamin --help` for more information.');
			return process.exit(1);
		}

		if (parsed['newline-separator']) {
			newlineSeparator = true;
		}

		if (parsed['minify-member-names']) {
			minifyMemberNames = true;
		}

		if (parsed['minify-table-key-strings']) {
			minifyTableKeyStrings = true;
		}

		if (parsed['minify-assigned-global-vars']) {
			minifyAssignedGlobalVars = true;
		}

		if (parsed['minify-global-functions']) {
			minifyGlobalFunctions = true;
		}

		if (parsed['minify-all-global-vars']) {
			minifyAllGlobalVars = true;
		}

		if (snippets.length == 0) {
			err('Error: at least 1 positional argument must be provided ' +
				'when using --file, --ast or --code.');
			err('Try `luamin --help` for more information.');
			return process.exit(1);
		}

		snippets.forEach(function(snippet) {
			var result;
			if (isFile) {
				try {
					snippet = fs.readFileSync(snippet, 'utf8');
				} catch(error) {
					err('Error: no such file. (`%s`)', snippet);
					return process.exit(1);
				}
			}
			try {
				if (isAST) {
					snippet = JSON.parse(snippet);
				}
				var preferences = {
					'newlineSeparator': newlineSeparator,
					'minifyMemberNames': minifyMemberNames,
					'minifyTableKeyStrings': minifyTableKeyStrings,
					'minifyAssignedGlobalVars': minifyAssignedGlobalVars,
					'minifyGlobalFunctions': minifyGlobalFunctions,
					'minifyAllGlobalVars': minifyAllGlobalVars,
				}
				result = minify(snippet, preferences);
				log(result);
			} catch(error) {
				err(error.message + '\n');
				if (isAST) {
					err('Error: failed to minify. Make sure the AST contains a ' +
						'`globals` property and is');
					err('fully compatible with luaparse.');
				} else { // itâ€™s a snippet or an AST
					err('Error: failed to minify. Make sure the Lua code is valid.');
				}
				err('If you think this is a bug in luamin, please report it:');
				err('https://github.com/mathiasbynens/luamin/issues/new');
				err(
					'\nStack trace using luamin@%s and luaparse@%s:\n',
					luamin.version,
					require('luaparse').version
				);
				err(error.stack);
				return process.exit(1);
			}
		});
		// Return with exit status 0 outside of the `forEach` loop, in case
		// multiple snippets or files were passed in.
		return process.exit(0);

	};

	if (snippets[0] == '-') {
		// handle pipe
		data = '';
		stdin.on('data', function(chunk) {
			data += chunk;
		});
		stdin.on('end', function() {
			if (data.trim().length != 0) {
				snippets[0] = data.trim();
			}
			main();
		});
		stdin.resume();
	} else {
		main();
	}

}());
